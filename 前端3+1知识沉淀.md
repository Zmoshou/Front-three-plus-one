# 前端3+1知识沉淀

### 2020.07.26 => 第1天 (2019.04.17)

- [html] [页面导入样式时，使用link和@import有什么区别？](https://github.com/haizlin/fe-interview/issues/1)

  ```
  1.link是HTML标签，@import是css提供的。
  2.link引入的样式页面加载时同时加载，@import引入的样式需等页面加载完成后再加载。
  3.link没有兼容性问题，@import不兼容ie5以下。
  4.link可以通过js操作DOM动态引入样式表改变样式，而@import不可以。
  ```

  

- [css] [圣杯布局和双飞翼布局的理解和区别，并用代码实现](https://github.com/haizlin/fe-interview/issues/2)

  ```html
  //圣杯布局
  <body>
  <div id="hd">header</div>
  <div id="bd">
    <div id="middle">middle</div>
    <div id="left">left</div>
    <div id="right">right</div>
  </div>
  <div id="footer">footer</div>
  </body>
  
  <style>
  #hd{
      height:50px;
      background: #666;
      text-align: center;
  }
  #bd{
      /*左右栏通过添加负的margin放到正确的位置了，此段代码是为了摆正中间栏的位置*/
      padding:0 200px 0 180px;
      height:100px;
  }
  #middle{
      float:left;
      width:100%;/*左栏上去到第一行*/
      height:100px;
      background:blue;
  }
  #left{
      float:left;
      width:180px;
      height:100px;
      margin-left:-100%;
      background:#0c9;
      /*中间栏的位置摆正之后，左栏的位置也相应右移，通过相对定位的left恢复到正确位置*/
      position:relative;
      left:-180px;
  }
  #right{
      float:left;
      width:200px;
      height:100px;
      margin-left:-200px;
      background:#0c9;
      /*中间栏的位置摆正之后，右栏的位置也相应左移，通过相对定位的right恢复到正确位置*/
      position:relative;
      right:-200px;
  }
  #footer{
      height:50px;
      background: #666;
      text-align: center;
  }
  </style>
  ```

  ```html
  //双飞翼布局
  <body>
  <div id="hd">header</div> 
    <div id="middle">
      <div id="inside">middle</div>
    </div>
    <div id="left">left</div>
    <div id="right">right</div>
    <div id="footer">footer</div>
  </body>
  
  <style>
  #hd{
      height:50px;
      background: #666;
      text-align: center;
  }
  #middle{
      float:left;
      width:100%;/*左栏上去到第一行*/     
      height:100px;
      background:blue;
  }
  #left{
      float:left;
      width:180px;
      height:100px;
      margin-left:-100%;
      background:#0c9;
  }
  #right{
      float:left;
      width:200px;
      height:100px;
      margin-left:-200px;
      background:#0c9;
  }
  
  /*给内部div添加margin，把内容放到中间栏，其实整个背景还是100%*/ 
  #inside{
      margin:0 200px 0 180px;
      height:100px;
  }
  #footer{  
     clear:both; /*记得清楚浮动*/  
     height:50px;     
     background: #666;    
     text-align: center; 
  } 
  </style>
  ```

  

- [js] [用递归算法实现，数组长度为5且元素的随机数在2-32间不重复的值](https://github.com/haizlin/fe-interview/issues/3)

  ```javascript
  function buildArray(arr, length, min, max) {
      var num = Math.floor(Math.random() * (max - min + 1)) + min;
      if (!arr.includes(num)) { arr.push(num); }
      return arr.length === length ? arr : buildArray(arr, length, min, max);
  }
  var result = buildArray([], 5, 2, 32);
  console.table(result);
  ```


### 2020.07.27 => 第2天 (2019.04.18)

-  [html] [html的元素有哪些（包含H5）？](https://github.com/haizlin/fe-interview/issues/4) 

  ```
  行内元素：
  a
  b
  span
  strong
  i
  em
  button
  input
  label
  br
  textarea
  select
  
  块元素
  div
  p
  h1-h6
  ol
  ul
  li
  table
  tbody
  td
  tr
  thead
  dl
  dt
  dd
  
  H5新增元素
  section
  article
  audio
  video
  hearder
  footer
  small
  ```

-  [css] [CSS3有哪些新增的特性？](https://github.com/haizlin/fe-interview/issues/5) 

  ```
  边框圆角 border-radius
  盒子阴影 box-shadow
  文字阴影 text-shadow
  2d、3d变换 transform rotate() scale() skew() translate()
  flex布局
  过度动画 transition
  自定义动画 animation
  边框图像 border-image
  线性渐变 linear-gradient
  径向渐变 radial-gradient
  多媒体查询 @media
  滤镜 filter
  
  新增css3伪类
  :after 在元素之前添加内容，也可以用来做清除浮动。
  :before 在元素之后添加内容。
  :enabled 选择可用的表单元素。
  :disabled 控制表单控件的禁用状态。
  :checked 单选框或复选框被选中。
  
  ```

- [js] [写一个方法去掉字符串中的空格](https://github.com/haizlin/fe-interview/issues/6)

  ```
  Regex: string.replace(/\s/g, '')
  join: string.split(' ').join('')
  
  var str = ' 1 2 3445 6    ';
  console.log(str.split(' ').join('')) // 输出"1234456"
  ```

### 2020.07.29 => 第3天 (2019.04.19)

-  [html] [HTML全局属性(global attribute)有哪些（包含H5）？](https://github.com/haizlin/fe-interview/issues/7) 

  ```
  class
  id
  data
  type
  href
  style
  width
  height
  targe
  checked
  disabled
  requie
  ref
  alt
  title
  name
  mulitp...多选
  value
  replaceholder
  src
  ```

-  [css] [在页面上隐藏元素的方法有哪些？](https://github.com/haizlin/fe-interview/issues/8) 

  ```
  display: none
  opacity: 0
  visibility: hidden
  -----------------------------
  z-index: -9999999999999
  transform: scale(0)
  margin-left: -100%
  position: relative; left: -100%
  width: 0; height: 0;
  ```

-  [js] [去除字符串中最后一个指定的字符](https://github.com/haizlin/fe-interview/issues/9) 

  ```javascript
  function delLast (str,del) {
  	if (tpeof str !== 'string') {
  		alert('请确认要删除的对象为字符串！');
  		retrun false;
  	} else {
  		let index = str.lastIndexOf(del);
  		str.substring(0,index ) + str.substring(index+1,str.length);
  	}
  }
  ```


### 2020.07.30 => 第4天 (2019.04.20)

-  [html] [HTML5的文件离线存储怎么使用，工作原理是什么？](https://github.com/haizlin/fe-intervie

  ```javascript
  1. LocalStorage就是Key-Value的简单键值对存储结构，Web Storage除了localStorage的持久性存储外，还有针对本次回话的sessionStorage方式，一般情况下localStorage较为常用
  window.localStorage
  localStorage.setItem("key", "value"); 存储
  var lastname = localStorage.getItem("key"); 读取
  localStorage.removeItem("key"); 删除
  
  2.使用 sessionStorage 创建一个本地存储的 name/value 对，name="lastname" value="Smith", 然后检索 "lastname" 的值，并插入到 id="result" 的元素上:
  // 存储
  sessionStorage.setItem("lastname", "Smith");
  // 检索
  document.getElementById("result").innerHTML = sessionStorage.getItem("lastname");
  sessionStorage 用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。
  
  3.Cookie
  Cookie 是一些数据, 存储于你电脑上的文本文件中。
  当 web 服务器向浏览器发送 web 页面时，在连接关闭后，服务端不会记录用户的信息。
  Cookie 的作用就是用于解决 "如何记录客户端的用户信息":
  
  当用户访问 web 页面时，他的名字可以记录在 cookie 中。
  在用户下一次访问该页面时，可以在 cookie 中读取用户访问记录。
  Cookie 以名/值对形式存储，如下所示:  username=John Doe
  
  设置 cookie 值的函数
  function setCookie(cname,cvalue,exdays)
  {
    var d = new Date();
    d.setTime(d.getTime()+(exdays*24*60*60*1000));
    var expires = "expires="+d.toGMTString();
    document.cookie = cname + "=" + cvalue + "; " + expires;
  }
  
  获取 cookie 值的函数
  function getCookie(cname)
  {
    var name = cname + "=";
    var ca = document.cookie.split(';');
    for(var i=0; i<ca.length; i++) 
    {
      var c = ca[i].trim();
      if (c.indexOf(name)==0) return c.substring(name.length,c.length);
    }
    return "";
  }
  
  检测 cookie 值的函数
  function checkCookie()
  {
    var username=getCookie("username");
    if (username!="")
    {
      alert("Welcome again " + username);
    }
    else 
    {
      username = prompt("Please enter your name:","");
      if (username!="" && username!=null)
      {
        setCookie("username",username,365);
      }
    }
  }
  
  4.IndexedDB
  IndexedDB是一种底层API，用于客户端存储大量结构化数据(包括, 文件/ 二进制大型对象(blobs)。该API使用索引来实现对该数据的高性能搜索。
  //	待补充.....
                                   
```
  
-   [css] [CSS选择器有哪些？哪些属性可以继承？](https://github.com/haizlin/fe-interview/issues/11) 

   | 选择器               | 例子                  | 例子描述                                       | CSS  |
   | -------------------- | --------------------- | ---------------------------------------------- | ---- |
   | .class               | .intro                | 选择 class="intro" 的所有元素。                | 1    |
   | #id                  | #firstname            | 选择 id="firstname" 的所有元素。               | 1    |
   | *                    | *                     | 选择所有元素。                                 | 2    |
   | element              | p                     | 选择所有元素。                                 | 1    |
   | element,element      | div,p                 | 选择所有元素和所有元素。                       | 1    |
   | element element      | div p                 | 选择元素内部的所有元素。                       | 1    |
   | element>element      | div>p                 | 选择父元素为元素的所有元素。                   | 2    |
   | element+element      | div+p                 | 选择紧接在元素之后的所有元素。                 | 2    |
   | [attribute]          | [target]              | 选择带有 target 属性所有元素。                 | 2    |
   | [attribute=value]    | [target=_blank]       | 选择 target="_blank" 的所有元素。              | 2    |
   | [attribute~=value]   | [title~=flower]       | 选择 title 属性包含单词 "flower" 的所有元素。  | 2    |
   | [attribute\|=value]  | [lang\|=en]           | 选择 lang 属性值以 "en" 开头的所有元素。       | 2    |
   | :link                | a:link                | 选择所有未被访问的链接。                       | 1    |
   | :visited             | a:visited             | 选择所有已被访问的链接。                       | 1    |
   | :active              | a:active              | 选择活动链接。                                 | 1    |
   | :hover               | a:hover               | 选择鼠标指针位于其上的链接。                   | 1    |
   | :focus               | input:focus           | 选择获得焦点的 input 元素。                    | 2    |
   | :first-letter        | p:first-letter        | 选择每个元素的首字母。                         | 1    |
   | :first-line          | p:first-line          | 选择每个元素的首行。                           | 1    |
   | :first-child         | p:first-child         | 选择属于父元素的第一个子元素的每个元素。       | 2    |
   | :before              | p:before              | 在每个元素的内容之前插入内容。                 | 2    |
   | :after               | p:after               | 在每个元素的内容之后插入内容。                 | 2    |
   | :lang(language)      | p:lang(it)            | 选择带有以 "it" 开头的 lang 属性值的每个元素。 | 2    |
   | element1~element2    | p~ul                  | 选择前面有元素的每个元素。                     | 3    |
   | [attribute^=value]   | a[src^="https"]       | 选择其 src 属性值以 "https" 开头的每个 元素。  | 3    |
   | [attribute$=value]   | a[src$=".pdf"]        | 选择其 src 属性以 ".pdf" 结尾的所有 元素。     | 3    |
   | [attribute*=value]   | a[src*="abc"]         | 选择其 src 属性中包含 "abc" 子串的每个 元素。  | 3    |
   | :first-of-type       | p:first-of-type       | 选择属于其父元素的首个元素的每个元素。         | 3    |
   | :last-of-type        | p:last-of-type        | 选择属于其父元素的最后元素的每个元素。         | 3    |
   | :only-of-type        | p:only-of-type        | 选择属于其父元素唯一的元素的每个元素。         | 3    |
   | :only-child          | p:only-child          | 选择属于其父元素的唯一子元素的每个元素。       | 3    |
   | :nth-child(n)        | p:nth-child(2)        | 选择属于其父元素的第二个子元素的每个元素。     | 3    |
   | :nth-last-child(n)   | p:nth-last-child(2)   | 同上，从最后一个子元素开始计数。               | 3    |
   | :nth-of-type(n)      | p:nth-of-type(2)      | 选择属于其父元素第二个元素的每个元素。         | 3    |
   | :nth-last-of-type(n) | p:nth-last-of-type(2) | 同上，但是从最后一个子元素开始计数。           | 3    |
   | :last-child          | p:last-child          | 选择属于其父元素最后一个子元素每个元素。       | 3    |
   | :root                | :root                 | 选择文档的根元素。                             | 3    |
   | :empty               | p:empty               | 选择没有子元素的每个元素（包括文本节点）。     | 3    |
   | :target              | #news:target          | 选择当前活动的 #news 元素。                    | 3    |
   | :enabled             | input:enabled         | 选择每个启用的 元素。                          | 3    |
   | :disabled            | input:disabled        | 选择每个禁用的 元素                            | 3    |
   | :checked             | input:checked         | 选择每个被选中的 元素。                        | 3    |
   | :not(selector)       | :not(p)               | 选择非元素的每个元素。                         | 3    |
   | ::selection          | ::selection           | 选择被用户选取的元素部分。                     | 3    |

   **哪些属性可以继承**

   1. 所有元素都可以继承

   - `visibility`和`cursor`

   2. 内联元素可以继承

   - `letter-spacing`：字符之间的间隙
   - `word-spacing`：单词之间的间隙
   - `white-space`：换行方式
   - `line-height`：行高
   - `color`：颜色
   - `font`：字体设置
   - `font-family`：字体名称
   - `font-size`：字体大小
   - `font-style`：字体样式
   - `font-variant`：是否为小型的大写字母
   - `font-weight`：文本字体的粗细
   - `text- decoration`：复合属性。文本的装饰。
   - `text-transform`：文本的大小写
   - `direction`：文本流的方向

-  [js] [写一个方法把下划线命名转成大驼峰命名](https://github.com/haizlin/fe-interview/issues/12) 

  ```javascript
          function changeLine(str) {
              if (typeof str !== 'string') {
                  alert('请确认要删除的对象为字符串！');
              } else {
                  var newName = '';
                  var arr = str.split('_');
                  arr.map((v, i) => {
                      if (i === 0) {
                          return
                      };
                      newName += v.substr(0, 1).toUpperCase() + v.substr(1);
                  })
                  return newName;
              }
          }
  ```

  